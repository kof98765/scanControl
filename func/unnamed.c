/*****************************************************************************/
/*  File generated by HDevelop for HALCON/C Version 10.0                      */
/*****************************************************************************/



#include "HalconC.h"


/* Procedure declarations */
/* Chapter: Develop*/
/* Short Description: Open a new graphics window that preserves the aspect ratio of the given image.*/
void dev_open_window_fit_image (Hobject Image, Htuple Row, Htuple Column, Htuple WidthLimit, 
    Htuple HeightLimit, Htuple *WindowHandle);

/* Procedures */
/* Chapter: Develop*/
/* Short Description: Open a new graphics window that preserves the aspect ratio of the given image.*/
void dev_open_window_fit_image (Hobject Image, Htuple Row, Htuple Column, Htuple WidthLimit, 
    Htuple HeightLimit, Htuple *WindowHandle)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Local control variables */
  Htuple  MinWidth, MaxWidth, MinHeight, MaxHeight;
  Htuple  ResizeFactor, ImageWidth, ImageHeight, TempWidth;
  Htuple  TempHeight, WindowWidth, WindowHeight;

  /* Initialize control variables */
  create_tuple(&(*WindowHandle),0);
  create_tuple(&MinWidth,0);
  create_tuple(&MaxWidth,0);
  create_tuple(&MinHeight,0);
  create_tuple(&MaxHeight,0);
  create_tuple(&ResizeFactor,0);
  create_tuple(&ImageWidth,0);
  create_tuple(&ImageHeight,0);
  create_tuple(&TempWidth,0);
  create_tuple(&TempHeight,0);
  create_tuple(&WindowWidth,0);
  create_tuple(&WindowHeight,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*This procedure opens a new graphics window and adjusts the size*/
  /*such that it fits into the limits specified by WidthLimit*/
  /*and HeightLimit, but also maintains the correct image aspect ratio.*/
  /**/
  /*If it is impossible to match the minimum and maximum extent requirements*/
  /*at the same time (f.e. if the image is very long but narrow),*/
  /*the maximum value gets a higher priority,*/
  /**/
  /*Parse input tuple WidthLimit*/
  /*========== if (|WidthLimit|=0 or WidthLimit<0) ==========*/
  T_tuple_length(WidthLimit,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_less(WidthLimit,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  if(get_i(TTemp[SP-1],0))
  {
    /*MinWidth := 500*/
    reuse_tuple_i(&MinWidth,500);

    /*MaxWidth := 800*/
    reuse_tuple_i(&MaxWidth,800);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (|WidthLimit|=1) ==========*/

  T_tuple_length(WidthLimit,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  if(get_i(TTemp[SP-1],0))
  {
    /*MinWidth := 0*/
    reuse_tuple_i(&MinWidth,0);

    /*MaxWidth := WidthLimit*/
    destroy_tuple(MaxWidth);
    copy_tuple(WidthLimit,&MaxWidth);

  }
  else
  {
    /*MinWidth := WidthLimit[0]*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_select(WidthLimit,TTemp[SP-1],    &TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(MinWidth);
    MinWidth=TTemp[--SP];

    /*MaxWidth := WidthLimit[1]*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_select(WidthLimit,TTemp[SP-1],    &TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(MaxWidth);
    MaxWidth=TTemp[--SP];

  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Parse input tuple HeightLimit*/
  /*========== if (|HeightLimit|=0 or HeightLimit<0) ==========*/
  T_tuple_length(HeightLimit,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_less(HeightLimit,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  if(get_i(TTemp[SP-1],0))
  {
    /*MinHeight := 400*/
    reuse_tuple_i(&MinHeight,400);

    /*MaxHeight := 600*/
    reuse_tuple_i(&MaxHeight,600);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (|HeightLimit|=1) ==========*/

  T_tuple_length(HeightLimit,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  if(get_i(TTemp[SP-1],0))
  {
    /*MinHeight := 0*/
    reuse_tuple_i(&MinHeight,0);

    /*MaxHeight := HeightLimit*/
    destroy_tuple(MaxHeight);
    copy_tuple(HeightLimit,&MaxHeight);

  }
  else
  {
    /*MinHeight := HeightLimit[0]*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_select(HeightLimit,TTemp[SP-1],    &TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(MinHeight);
    MinHeight=TTemp[--SP];

    /*MaxHeight := HeightLimit[1]*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_select(HeightLimit,TTemp[SP-1],    &TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(MaxHeight);
    MaxHeight=TTemp[--SP];

  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Test, if window size has to be changed.*/
  /*ResizeFactor := 1*/
  reuse_tuple_i(&ResizeFactor,1);

  /*get_image_size (Image, ImageWidth, ImageHeight)*/
  destroy_tuple(ImageWidth);
  destroy_tuple(ImageHeight);
  /***/T_get_image_size(Image, &ImageWidth, &ImageHeight);

  /*First, expand window to the minimum extents (if necessary).*/
  /*========== if (MinWidth>ImageWidth or MinHeight>ImageHeight) ==========*/
  T_tuple_greater(MinWidth,ImageWidth,&TTemp[SP++]);
  T_tuple_greater(MinHeight,ImageHeight,&TTemp[SP++]);
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  if(get_i(TTemp[SP-1],0))
  {
    /*ResizeFactor := max([real(MinWidth)/ImageWidth,real(MinHeight)/ImageHeight])*/
    T_tuple_real(MinWidth,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],ImageWidth,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_real(MinHeight,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],ImageHeight,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP=SP-1;
    T_tuple_max(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(ResizeFactor);
    ResizeFactor=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*TempWidth := ImageWidth*ResizeFactor*/
  T_tuple_mult(ImageWidth,ResizeFactor,&TTemp[SP++]);
  destroy_tuple(TempWidth);
  TempWidth=TTemp[--SP];

  /*TempHeight := ImageHeight*ResizeFactor*/
  T_tuple_mult(ImageHeight,ResizeFactor,&TTemp[SP++]);
  destroy_tuple(TempHeight);
  TempHeight=TTemp[--SP];

  /*Then, shrink window to maximum extents (if necessary).*/
  /*========== if (MaxWidth<TempWidth or MaxHeight<TempHeight) ==========*/
  T_tuple_less(MaxWidth,TempWidth,&TTemp[SP++]);
  T_tuple_less(MaxHeight,TempHeight,&TTemp[SP++]);
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  if(get_i(TTemp[SP-1],0))
  {
    /*ResizeFactor := ResizeFactor*min([real(MaxWidth)/TempWidth,real(MaxHeight)/TempHeight])*/
    copy_tuple(ResizeFactor,&TTemp[SP++]);
    T_tuple_real(MaxWidth,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],TempWidth,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_real(MaxHeight,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],TempHeight,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP=SP-1;
    T_tuple_min(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP=SP-1;
    destroy_tuple(ResizeFactor);
    ResizeFactor=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*WindowWidth := ImageWidth*ResizeFactor*/
  T_tuple_mult(ImageWidth,ResizeFactor,&TTemp[SP++]);
  destroy_tuple(WindowWidth);
  WindowWidth=TTemp[--SP];

  /*WindowHeight := ImageHeight*ResizeFactor*/
  T_tuple_mult(ImageHeight,ResizeFactor,&TTemp[SP++]);
  destroy_tuple(WindowHeight);
  WindowHeight=TTemp[--SP];

  /*Resize window*/
  /*dev_open_window (Row, Column, WindowWidth, WindowHeight, 'black', WindowHandle)*/
  create_tuple_s(&TTemp[SP++],"black");
  create_tuple_s(&TTemp[SP++],"background_color");
  T_set_window_attr(TTemp[SP-1],TTemp[SP-2]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_s(&TTemp[SP++],"");
  create_tuple_s(&TTemp[SP++],"");
  destroy_tuple((*WindowHandle));
  /***/T_open_window(Row,Column,WindowWidth,WindowHeight,TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&(*WindowHandle));
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  window_stack_push(get_i((*WindowHandle),0));

  if (window_stack_is_open())
  {
    Htuple active_win;
    create_tuple_i(&active_win,window_stack_get_active());
    /*dev_set_part (0, 0, ImageHeight-1, ImageWidth-1)*/
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(ImageHeight,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(ImageWidth,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_set_part(active_win,TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(active_win);
  }
  /*========== return ==========*/
  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear local control variables */
  destroy_tuple(MinWidth);
  destroy_tuple(MaxWidth);
  destroy_tuple(MinHeight);
  destroy_tuple(MaxHeight);
  destroy_tuple(ResizeFactor);
  destroy_tuple(ImageWidth);
  destroy_tuple(ImageHeight);
  destroy_tuple(TempWidth);
  destroy_tuple(TempHeight);
  destroy_tuple(WindowWidth);
  destroy_tuple(WindowHeight);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/
}

#ifndef NO_EXPORT_MAIN
/* Main procedure */
void action()
{
  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Local iconic variables */
  Hobject  Image;

  /* Local control variables */
  Htuple  WindowHandle;

  /* Initialize iconic variables */
  gen_empty_obj(&Image);

  /* Initialize control variables */
  create_tuple(&WindowHandle,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*read_image (Image, 'D:/halcon_learn/E128/image/1a.jpg')*/
  clear_obj(Image);
  /***/read_image(&Image, "D:/halcon_learn/E128/image/1a.jpg");

  /*dev_open_window_fit_image (Image, 0, 0, -1, -1, WindowHandle)*/
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],-1);
  create_tuple_i(&TTemp[SP++],-1);
  destroy_tuple(WindowHandle);
  /***/dev_open_window_fit_image(Image, TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], 
      &WindowHandle);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  if (window_stack_is_open())
  {
    Htuple active_win;
    create_tuple_i(&active_win,window_stack_get_active());
    /*dev_display (Image)*/
    /***/T_disp_obj(Image, active_win);
    destroy_tuple(active_win);
  }

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/
  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear local iconic variables */
  clear_obj(Image);

  /* Clear local control variables */
  destroy_tuple(WindowHandle);

}


#ifndef NO_EXPORT_APP_MAIN
int main(int argc, char *argv[])
{
  /* Default settings used in HDevelop (can be omitted) */
  set_system("do_low_error","false");
  action();
  return 0;
}
#endif


#endif


