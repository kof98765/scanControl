///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 10.0
///////////////////////////////////////////////////////////////////////////////



#include "HalconCpp.h"



using namespace Halcon;

// Default exception handler 
void CPPExpDefaultExceptionHandler(const Halcon::HException& except)
{
  throw except;
}

// Procedure declarations 
// Chapter: Graphics / Text
// Short Description: Set font independent of OS
void set_display_font (Halcon::HTuple WindowHandle, Halcon::HTuple Size, Halcon::HTuple Font, 
    Halcon::HTuple Bold, Halcon::HTuple Slant);
// Local procedures 
void Draw_Fuction (Halcon::Hobject *Area, Halcon::HTuple Mode, Halcon::HTuple WindowHandle);
void Total_Paint_Region (Halcon::Hobject Region, Halcon::Hobject Image, Halcon::Hobject *ResultImage, 
    Halcon::HTuple Color, Halcon::HTuple RegionDL, Halcon::HTuple LinesWidths);
void GrayToRgb (Halcon::Hobject GrayImage, Halcon::Hobject *RGBImage);
void GrayToRgbValue (Halcon::HTuple GrayValue, Halcon::HTuple Standard, Halcon::HTuple *RGBValue);

// Procedures 
// Chapter: Graphics / Text
// Short Description: Set font independent of OS
void set_display_font (Halcon::HTuple WindowHandle, Halcon::HTuple Size, Halcon::HTuple Font, 
    Halcon::HTuple Bold, Halcon::HTuple Slant)
{
  using namespace Halcon;

  // Local control variables 
  HTuple  OS, Exception, AllowedFontSizes, Distances;
  HTuple  Indices;


  // Install default exception handler 
  HException::InstallHHandler(&CPPExpDefaultExceptionHandler);

  //This procedure sets the text font of the current window with
  //the specified attributes.
  //It is assumed that following fonts are installed on the system:
  //Windows: Courier New, Arial Times New Roman
  //Linux: courier, helvetica, times
  //Because fonts are displayed smaller on Linux than on Windows,
  //a scaling factor of 1.25 is used the get comparable results.
  //For Linux, only a limited number of font sizes is supported,
  //to get comparable results, it is recommended to use one of the
  //following sizes: 9, 11, 14, 16, 20, 27
  //(which will be mapped internally on Linux systems to 11, 14, 17, 20, 25, 34)
  //
  //input parameters:
  //WindowHandle: The graphics window for which the font will be set
  //Size: The font size. If Size=-1, the default of 16 is used.
  //Bold: If set to 'true', a bold font is used
  //Slant: If set to 'true', a slanted font is used
  //
  get_system("operating_system", &OS);
  if (0 != (HTuple(Size==HTuple()).Or(Size==-1)))
  {
    Size = 16;
  }
  if (0 != ((OS.Substring(0,2))==HTuple("Win")))
  {
    //set font on Windows systems
    if (0 != (HTuple(HTuple(Font==HTuple("mono")).Or(Font==HTuple("Courier"))).Or(Font==HTuple("courier"))))
    {
      Font = "Courier New";
    }
    else if (0 != (Font==HTuple("sans")))
    {
      Font = "Arial";
    }
    else if (0 != (Font==HTuple("serif")))
    {
      Font = "Times New Roman";
    }
    if (0 != (Bold==HTuple("true")))
    {
      Bold = 1;
    }
    else if (0 != (Bold==HTuple("false")))
    {
      Bold = 0;
    }
    else
    {
      Exception = "Wrong value of control parameter Bold";
      throw HException(Exception);
    }
    if (0 != (Slant==HTuple("true")))
    {
      Slant = 1;
    }
    else if (0 != (Slant==HTuple("false")))
    {
      Slant = 0;
    }
    else
    {
      Exception = "Wrong value of control parameter Slant";
      throw HException(Exception);
    }
    try
    {
      set_font(WindowHandle, ((((((("-"+Font)+"-")+Size)+"-*-")+Slant)+"-*-*-")+Bold)+"-");
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&Exception);
      throw HException(Exception);
    }
  }
  else
  {
    //set font for UNIX systems
    Size = Size*1.25;
    AllowedFontSizes.Reset();
    AllowedFontSizes[0] = 11;
    AllowedFontSizes[1] = 14;
    AllowedFontSizes[2] = 17;
    AllowedFontSizes[3] = 20;
    AllowedFontSizes[4] = 25;
    AllowedFontSizes[5] = 34;
    if (0 != ((AllowedFontSizes.Find(Size))==-1))
    {
      Distances = (AllowedFontSizes-Size).Abs();
      tuple_sort_index(Distances, &Indices);
      Size = AllowedFontSizes[HTuple(Indices[0])];
    }
    if (0 != (HTuple(Font==HTuple("mono")).Or(Font==HTuple("Courier"))))
    {
      Font = "courier";
    }
    else if (0 != (Font==HTuple("sans")))
    {
      Font = "helvetica";
    }
    else if (0 != (Font==HTuple("serif")))
    {
      Font = "times";
    }
    if (0 != (Bold==HTuple("true")))
    {
      Bold = "bold";
    }
    else if (0 != (Bold==HTuple("false")))
    {
      Bold = "medium";
    }
    else
    {
      Exception = "Wrong value of control parameter Bold";
      throw HException(Exception);
    }
    if (0 != (Slant==HTuple("true")))
    {
      if (0 != (Font==HTuple("times")))
      {
        Slant = "i";
      }
      else
      {
        Slant = "o";
      }
    }
    else if (0 != (Slant==HTuple("false")))
    {
      Slant = "r";
    }
    else
    {
      Exception = "Wrong value of control parameter Slant";
      throw HException(Exception);
    }
    try
    {
      set_font(WindowHandle, ((((((("-adobe-"+Font)+"-")+Bold)+"-")+Slant)+"-normal-*-")+Size)+"-*-*-*-*-*-*-*");
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&Exception);
      throw HException(Exception);
    }
  }
  return;
}

// Local procedures 
void Draw_Fuction (Halcon::Hobject *Area, Halcon::HTuple Mode, Halcon::HTuple WindowHandle)
{
  using namespace Halcon;

  // Local control variables 
  HTuple  Row1, Column1, Row2, Column2, Row, Column;
  HTuple  Radius, Phi, Radius1, Radius2, Length1, Length2;


  if (0 != (Mode==0))
  {
    draw_line(WindowHandle, &Row1, &Column1, &Row2, &Column2);
    gen_region_line(&(*Area), Row1, Column1, Row2, Column2);
  }
  else if (0 != (Mode==1))
  {
    draw_circle(WindowHandle, &Row, &Column, &Radius);
    gen_circle(&(*Area), Row, Column, Radius);
  }
  else if (0 != (Mode==2))
  {
    draw_ellipse(WindowHandle, &Row, &Column, &Phi, &Radius1, &Radius2);
    gen_ellipse(&(*Area), Row, Column, Phi, Radius1, Radius2);
  }
  else if (0 != (Mode==3))
  {
    draw_rectangle1(WindowHandle, &Row1, &Column1, &Row2, &Column2);
    gen_rectangle1(&(*Area), Row1, Column1, Row2, Column2);
  }
  else if (0 != (Mode==4))
  {
    draw_rectangle2(WindowHandle, &Row, &Column, &Phi, &Length1, &Length2);
    gen_rectangle2(&(*Area), Row, Column, Phi, Length1, Length2);
  }
  else if (0 != (Mode==5))
  {
    draw_polygon(&(*Area), WindowHandle);
  }

  return;
}

void Total_Paint_Region (Halcon::Hobject Region, Halcon::Hobject Image, Halcon::Hobject *ResultImage, 
    Halcon::HTuple Color, Halcon::HTuple RegionDL, Halcon::HTuple LinesWidths)
{
  using namespace Halcon;

  // Local iconic variables 
  Hobject  RegionUnion, DefectAreaDL, RegionBorder;
  Hobject  RegionResult;


  // Local control variables 
  HTuple  Width, Height, tWindowHandle, Area, Row;
  HTuple  Column;

  get_image_size(Image, &Width, &Height);
  set_system("width", Width);
  set_system("height", Height);
  open_window(0, 0, -1, -1, 0, "invisible", "", &tWindowHandle);
  set_display_font(tWindowHandle, 15, "mono", "true", "false");
  set_window_extents(tWindowHandle, 0, 0, Width, Height);
  clear_window(tWindowHandle);
  //*******************PaintRegionColor
  if (0 != (Color==0))
  {
    set_color(tWindowHandle, "red");
  }
  else if (0 != (Color==1))
  {
    set_color(tWindowHandle, "green");
  }
  else if (0 != (Color==2))
  {
    set_color(tWindowHandle, "blue");
  }
  else if (0 != (Color==3))
  {
    set_color(tWindowHandle, "yellow");
  }
  else if (0 != (Color==4))
  {
    set_color(tWindowHandle, "gray");
  }
  else if (0 != (Color==5))
  {
    set_color(tWindowHandle, "pink");
  }
  //*******************PaintRegionLinesWidth
  union1(Region, &RegionUnion);
  dilation_circle(RegionUnion, &DefectAreaDL, RegionDL);
  boundary(DefectAreaDL, &RegionBorder, "outer");
  dilation_circle(RegionBorder, &RegionBorder, LinesWidths);
  union1(RegionBorder, &RegionResult);
  area_center(RegionResult, &Area, &Row, &Column);
  //*******************PaintRegion
  if (0 != (Area>0))
  {
    disp_obj(Image, tWindowHandle);
    disp_obj(RegionResult, tWindowHandle);
  }
  else
  {
    disp_obj(Image, tWindowHandle);
  }
  set_colored(tWindowHandle, 12);
  dump_window_image(&(*ResultImage), tWindowHandle);
  close_window(tWindowHandle);
  return;
}

void GrayToRgb (Halcon::Hobject GrayImage, Halcon::Hobject *RGBImage)
{
  using namespace Halcon;

  // Local iconic variables 
  Hobject  Domain, Imagetemp;


  // Local control variables 
  HTuple  Width, Height, Min, Max, Range, Stand;
  HTuple  i, j, Grayval, RGBValue;

  get_image_size(GrayImage, &Width, &Height);
  get_domain(GrayImage, &Domain);
  min_max_gray(Domain, GrayImage, 0, &Min, &Max, &Range);
  Stand = Range/7;
  gen_image_const(&Imagetemp, "byte", Width, Height);
  cfa_to_rgb(Imagetemp, &(*RGBImage), "bayer_gb", "bilinear");
  for (i=0; i<=Height-1; i+=1)
  {
    for (j=0; j<=Width-1; j+=1)
    {
      get_grayval(GrayImage, i, j, &Grayval);
      GrayToRgbValue(Grayval-Min, Stand, &RGBValue);
      set_grayval((*RGBImage), i, j, RGBValue);
    }
  }
  return;

}

void GrayToRgbValue (Halcon::HTuple GrayValue, Halcon::HTuple Standard, Halcon::HTuple *RGBValue)
{
  using namespace Halcon;

  // Local control variables 
  HTuple  Value;

  Value = GrayValue/Standard;
  tuple_int(Value, &Value);
  //switch (Value)
  //case ()
  (*RGBValue).Reset();
  (*RGBValue).Append(128-((GrayValue*128)/Standard));
  (*RGBValue).Append(0);
  (*RGBValue).Append(255);
  //break
  //case ()
  (*RGBValue).Reset();
  (*RGBValue)[0] = 0;
  (*RGBValue).Append(((GrayValue-Standard)*255)/Standard);
  (*RGBValue).Append(255);
  //break
  //case ()
  (*RGBValue).Reset();
  (*RGBValue)[0] = 0;
  (*RGBValue)[1] = 255;
  (*RGBValue).Append(255-(((GrayValue-(Standard*2))*255)/Standard));
  //break
  //case ()
  (*RGBValue).Reset();
  (*RGBValue).Append(((GrayValue-(Standard*3))*255)/Standard);
  (*RGBValue).Append(255);
  (*RGBValue).Append(0);
  //break
  //case ()
  (*RGBValue).Reset();
  (*RGBValue)[0] = 255;
  (*RGBValue).Append(255-(((GrayValue-(Standard*4))*128)/Standard));
  (*RGBValue).Append(0);
  //break
  //case ()
  (*RGBValue).Reset();
  (*RGBValue)[0] = 255;
  (*RGBValue).Append(128-(((GrayValue-(Standard*5))*128)/Standard));
  (*RGBValue).Append(0);
  //break
  //case ()
  (*RGBValue).Reset();
  (*RGBValue)[0] = 255;
  (*RGBValue).Append(((GrayValue-(Standard*6))*128)/Standard);
  (*RGBValue).Append(((GrayValue-(Standard*6))*128)/Standard);
  //break
  //endswitch ()
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{
  using namespace Halcon;

  // Local iconic variables 
  Hobject  Area, Image, Domain, RegionErosion, ResultImage;
  Hobject  RGBImage;

  //Draw_Fuction
  //Draw_Fuction (Area, 5, 3600)
  //Total_Paint_Region
  //read_image (Image, 'C:/1.tiff')
  //get_domain (Image, Domain)
  //erosion_circle (Domain, RegionErosion, 20)
  //Total_Paint_Region (RegionErosion, Image, ResultImage, 0, 1, 4)

  //2D GrayToColor
  read_image(&Image, "C:/2.tiff");
  GrayToRgb(Image, &RGBImage);
  write_image(RGBImage, "tiff", 0, "C:/temp.tiff");





}


#ifndef NO_EXPORT_APP_MAIN
int main(int argc, char *argv[])
{
  using namespace Halcon;
  // Default settings used in HDevelop (can be omitted) 
  set_system("do_low_error","false");
  action();
  return 0;
}
#endif


#endif


